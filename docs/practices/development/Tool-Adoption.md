

### Tool Use
 
In general, unless the problem is somehow _specific to your circumstances_ it may well be better to skip direct coding and pick up some new tools to help with the job.  

Tools are a different trade off to automation.  You are mitigating [Process Risk](../risks/Process-Risk.md) or [Feature Risk](../risks/Feature-Risk.md) in return for:
 - New [Dependency Risk](../risks/Dependency-Risk.md) on the new tool.
 - [Communication Risk](../risks/Communication-Risk.md) because now the team has to understand the tool.
 - [Schedule Risk](../risks/Scarcity-Risk.md#schedule-risk) in the time it takes to learn and integrate the tool.
 - [Complexity Risk](../risks/Complexity-Risk.md) because your project necessarily becomes more complex for the addition of the tool.

Tools in general are _good_ and _worth using_ if they offer you a better risk return than you would have had from not using them.  

But, this is a low bar -  some tools offer _amazing_ returns on investment.  The [Silver Bullets](../complexity/Silver-Bullets.md) article describes in general some of these: 
 - Assemblers
 - Compilers
 - Garbage Collection
 - Type Systems
 - Libraries
 - Build Tools
 - etc.

A _really good tool_ offers such advantages that not using it becomes _unthinkable_:  Linux is heading towards this point.   For Java developers, the JVM is there already.  

Picking new tools and libraries should be done **very carefully**:  you may be stuck with your choices for some time.  Here is a [short guide that might help](../risks/Dependency-Risk.md).
